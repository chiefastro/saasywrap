*What is saasywrap?*
saasywrap is a tool that allows non-technical admins to build databases that have user-friendly UIs (build arbitrary SaaS, a wrapper around a database).
The tool will use AI to generate the UI and the database schema, allowing the admin to focus only on the business logic of the application (a wrapper around AI models to build wrappers around databases)

*How does it work?*
The admin has a UI to describe the business logic of the application. The admin provides a description of the requirements along with a sample dataset (either Excel or CSV).

The AI will ask the admin questions to clarify the requirements and the sample dataset.

The AI will then generate the database schema and the UI.

The admin can then review the generated schema and UI, and provide feedback to the AI.

The AI will make updates, and the feedback loop continues until the admin is satisfied with the generated schema and UI.

The admin can then deploy the application on infrastructure managed by saasywrap.

The admin can then share the application with their users.

*Tech Stack*
- AI models
 - OpenAI
- Database
 - Postgres
- Infrastructure
 - AWS
 - Terraform
 - Github (platform repo, separate repo for each client's app)
- UI
 - HTML/CSS/JS
- Backend
 - Python, Flask

*UI Layout and Workflow*
The platform layout for admins to build their apps is as follows.

** Upload **
Admin starts on index.html (this is a single page app). There's a large text box to describe the requirements of the app. There's a button to upload a sample dataset (either Excel or CSV). These inputs take up the whole screen at first.

** Requirements **
Upon upload, the admin inputs are sent to the generate_requirements.py agent. The agent generates a list of atomic requirements based on the admin input. 

The admin is taken to a new screen called "Requirements Gathering". The requirements generated by the agent are displayed in a panel on the right. The left panel is a chat interface.

The agent will decide if it needs to ask the admin questions to collect additional requirements. Those questions are displayed in the chat interface on the left. Responses from the admin are sent back to the agent, which updates the requirements.

The admin can edit the requirements by clicking on a requirement and editing it. The admin can also add new requirements by clicking the "Add Requirement" button.

The chat interface can also be used to refine the set of requirements. 

** Plans **
After the admin is satisfied with the requirements, they click a button to generate a plan. The requirements are sent to the generate_plan.py agent and the admin enters a new screen. 

The agent generates an initial plan for the app. That plan is displayed in a panel on the right, and a chat dialogue is displayed on the left. The plan display and chat can be swapped out with the requirements display and chat with a navigation menu on the top right.

When on the Plans page, there will be a middle panel that will be a preview of the generated app (empty until after at least one plan step is executed).

The plan will be a list of steps that the admin can review and provide feedback on. The plan will be generated in a way that is easy to understand and modify for a non-technical admin.

When a plan is generated (either initial or after feedback), the agent may decide it needs to ask the admin a question. Those questions are displayed in the chat dialogue on the left. Responses from the admin are sent back to the agent, which updates the plan.

Each step in the plan is a separate, executable event. The admin can click a play button on any step to execute it. The step will be executed, and the result will be displayed in the middle panel.

The admin can also click a "play all" button to execute the entire plan, or a "next" button to execute the next step in the plan, or a "play until" button to execute the next steps in the plan until a certain step is reached.

The admin can choose to accept or reject the changes made by a step. If rejected, the step is rolled back, and the chat dialogue gets a question added asking why it was rejected.

