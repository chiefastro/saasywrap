*What is saasywrap?*
saasywrap is a tool that allows non-technical admins to build databases that have user-friendly UIs (build arbitrary SaaS, a wrapper around a database).
The tool will use AI to generate the UI and the database schema, allowing the admin to focus only on the business logic of the application (a wrapper around AI models to build wrappers around databases)

*How does it work?*
The admin has a UI to describe the business logic of the application. The admin provides a description of the requirements along with a sample dataset (either Excel or CSV).

The AI will ask the admin questions to clarify the requirements and the sample dataset.

The AI will then generate the database schema and the UI.

The admin can then review the generated schema and UI, and provide feedback to the AI.

The AI will make updates, and the feedback loop continues until the admin is satisfied with the generated schema and UI.

The admin can then deploy the application on infrastructure managed by saasywrap.

The admin can then share the application with their users.

*Tech Stack*
- AI models
 - OpenAI
- Database
 - Postgres
- Infrastructure
 - AWS
 - Terraform
 - Github (platform repo, separate repo for each client's app)
- UI
 - HTML/CSS/JS
- Backend
 - Python, Flask

*UI Layout and Workflow*
The platform layout for admins to build their apps is as follows.

** Upload **
Admin starts on index.html (this is a single page app). There's a large text box to describe the requirements of the app. There's a button to upload a sample dataset (either Excel or CSV). These inputs take up the whole screen at first.

** Requirements **
Upon upload, the admin inputs are sent to the generate_requirements.py agent. The agent generates a list of atomic requirements based on the admin input. 

The admin is taken to a new screen called "Requirements Gathering". The requirements generated by the agent are displayed in a panel on the right. The left panel is a chat interface.

The agent will decide if it needs to ask the admin questions to collect additional requirements. Those questions are displayed in the chat interface on the left. Responses from the admin are sent back to the agent, which updates the requirements.

The admin can edit the requirements by clicking on a requirement and editing it. The admin can also add new requirements by clicking the "Add Requirement" button.

The chat interface can also be used to refine the set of requirements. 

** Blueprints **
After the admin is satisfied with the requirements, they click a button to generate a blueprint. The requirements are sent to the generate_plan.py agent and the admin enters a new screen. 

The agent generates an initial blueprint for the app. That blueprint is displayed in a panel on the right, and a chat dialogue is displayed on the left. The blueprint display and chat can be swapped out with the requirements display and chat with a navigation menu on the top right.

When on the Blueprints page, there will be a middle panel that will be a preview of the generated app (empty until after at least one transform is executed).

The blueprint will be a list of transforms that the admin can review and provide feedback on. The blueprint will be generated in a way that is easy to understand and modify for a non-technical admin.

When a blueprint is generated (either initial or after feedback), the agent may decide it needs to ask the admin a question. Those questions are displayed in the chat dialogue on the left. Responses from the admin are sent back to the agent, which updates the blueprint.

Each transform in the blueprint is a separate, executable event. The admin can click a play button on any transform to execute it. The transform will be executed, and the result will be displayed in the middle panel.

The admin can also click a "play all" button to execute the entire blueprint, or a "next" button to execute the next transform in the blueprint, or a "play until" button to execute the next transforms in the blueprint until a certain transform is reached.

The admin can choose to accept or reject the changes made by a transform. If rejected, the transform is rolled back, and the chat dialogue gets a question added asking why it was rejected.

** Transforms **
Each step of a plan is called a Transform. A Transform is a self-contained unit that converts a subset of requirements into a specific component of the system. Each Transform has the following characteristics:

1. Requirements Assignment: A specific set of requirements from the overall requirements list is assigned to the Transform.

2. Single Agent Execution: Each Transform uses exactly one specialized agent to generate one piece of the system:
   - Schema Transform: Generates database tables and relationships
   - Form Transform: Creates UI components (HTML, CSS, Javascript) for CRUD operations on schema elements
   - View Transform: Builds detailed views of single instances that may span multiple database tables
   - Dashboard Transform: Produces aggregate views of multiple instances

3. Execution Metadata: Each Transform maintains execution information including:
   - Status (pending, in-progress, completed, failed)
   - Execution timestamps
   - Performance metrics
   - Other relevant metadata

4. Artifact Linkage: All artifacts produced during Transform execution (e.g., generated code, schemas, UI components) are linked directly to the Transform for easy reference and tracking.

5. Feedback Loop: Users can provide feedback on any aspect of the Transform through the chat interface, including:
   - Generated artifacts
   - Requirements interpretation
   - Design decisions
   - Implementation details

The Transform concept ensures that each piece of the system is generated in a modular, trackable way, with clear connections between requirements, generation process, and outputs. 

** Artifacts **
Artifacts are the persistent, functional outputs produced by Transforms. They represent the actual components of the generated application. The Artifacts screen allows admins to view and modify these components after they've been generated.

The Artifacts screen follows the consistent layout pattern:
- Left panel: Chat interface for discussing and refining artifacts
- Middle panel: Live preview of the selected artifact
- Right panel: List of all artifacts, organized by type:
  - Database Schemas
  - Forms
  - Views
  - Dashboards

Each artifact can be:
- Previewed in the middle panel
- Modified directly through a code editor
- Tested in isolation
- Rolled back to a previous version
- Exported for external use

** End-to-End Workflow **
The complete workflow for an admin to build their application follows these steps:

1. Requirements Phase
   - Describe application needs
   - Upload sample data
   - Review and refine generated requirements
   - Engage with AI to clarify requirements

2. Blueprint Phase
   - Generate initial blueprint from requirements
   - Review proposed transforms
   - Provide feedback and adjust blueprint
   - Execute transforms in desired order

3. Transform Phase
   - Monitor transform execution
   - Review generated artifacts
   - Accept or reject transform results
   - Provide feedback for rejected transforms

4. Artifact Phase
   - Review all generated artifacts
   - Test artifacts individually
   - Make manual adjustments if needed
   - Ensure artifacts work together as expected

5. Deployment Phase
   - Review complete application
   - Run final tests
   - Deploy to production
   - Share with end users

At any point in the workflow, the admin can:
- Return to a previous phase
- Modify earlier decisions
- Request AI assistance through the chat interface
- Preview the current state of the application 